---------------------------------------------------------------------------------------------
-- Requirement summary:
-- [RegisterAppInterface] "app_registration_language_vui" storage into PolicyTable
--
-- Check set value of "app_registration_language_vui" in Local Policy Table.
-- 1. Used preconditions:
-- Start default SDL
-- Add MobileApp to PreloadedPT
-- InitHMI register MobileApp
--
-- 2. Performed steps:
-- Stop SDL
-- Check LocalPT changes
--
-- Expected result:
-- SDL must: must write "languageDesired" value received via RegisterAppInterface into Local Policy Table
-- as "app_registration_language_vui" key value of "usage_and_error_counts"- >"app_level" - > <app id> section.
---------------------------------------------------------------------------------------------

--[[ General configuration parameters ]]
Test = require('connecttest')
local config = require('config')
config.defaultProtocolVersion = 2
config.deviceMAC = "12ca17b49af2289436f303e0166030a21e525d266e209267433801a8fd4071a0"

--[[ Required Shared libraries ]]
local json = require("modules/json")
local commonFunctions = require ('user_modules/shared_testcases/commonFunctions')
local commonSteps = require ('user_modules/shared_testcases/commonSteps')
local mobile_session = require('mobile_session')
require('cardinalities')
require('user_modules/AppTypes')

--[[ Local Variables ]]
local PRELOADED_PT_FILE_NAME = "sdl_preloaded_pt.json"
local HMIAppId
local APP_ID = "0000001"
local APP_LANGUAGE = "ES-MX"

local basic_ptu_file = "files/ptu.json"
local ptu_first_app_registered = "files/ptu1app.json"
local snapshot_path = "/tmp/fs/mp/images/ivsu_cache/sdl_snapshot.json"

local TESTED_DATA = {
  preloaded = {
    policy_table = {
      app_policies = {
        [APP_ID] = {
          keep_context = false,
          steal_focus = false,
          priority = "NONE",
          default_hmi = "NONE",
          groups = {"Base-4"},
          RequestType = {
            "TRAFFIC_MESSAGE_CHANNEL",
            "PROPRIETARY",
            "HTTP",
            "QUERY_APPS"
          }
        }
      }
    }
  },
  expected = {
    policy_table = {
      usage_and_error_counts = {
        app_level = {
          [APP_ID] = {
            app_registration_language_vui = APP_LANGUAGE
          }
        }
      }
    }
  },
  application = {
    registerAppInterfaceParams = {
      syncMsgVersion = {
        majorVersion = 3,
        minorVersion = 0
      },
      appName = "Test Application",
      isMediaApplication = true,
      languageDesired = APP_LANGUAGE,
      hmiDisplayLanguageDesired = 'EN-US',
      appHMIType = { "MEDIA" },
      appID = APP_ID,
      deviceInfo = {
        os = "Android",
        carrier = "Megafon",
        firmwareRev = "Name: Linux, Version: 3.4.0-perf",
        osVersion = "4.4.2",
        maxNumberRFCOMMPorts = 1
      }
    }
  }
}

local TestData = {
  path = config.pathToSDL .. "TestData",
  isExist = false,
  init = function(self)
    if not self.isExist then
      os.execute("mkdir ".. self.path)
      os.execute("echo 'List test data files files:' > " .. self.path .. "/index.txt")
      self.isExist = true
    end
  end,
  store = function(self, message, pathToFile, fileName)
    if self.isExist then
      local dataToWrite = message

      if pathToFile and fileName then
        os.execute(table.concat({"cp ", pathToFile, " ", self.path, "/", fileName}))
        dataToWrite = table.concat({dataToWrite, " File: ", fileName})
      end

      dataToWrite = dataToWrite .. "\n"
      local file = io.open(self.path .. "/index.txt", "a+")
      file:write(dataToWrite)
      file:close()
    end
  end,
  delete = function(self)
    if self.isExist then
      os.execute("rm -r -f " .. self.path)
      self.isExist = false
    end
  end,
  info = function(self)
    if self.isExist then
      commonFunctions:userPrint(35, "All test data generated by this test were stored to folder: " .. self.path)
    else
      commonFunctions:userPrint(35, "No test data were stored" )
    end
  end
}

local function constructPathToDatabase()
  if commonSteps:file_exists(config.pathToSDL .. "storage/policy.sqlite") then
    return config.pathToSDL .. "storage/policy.sqlite"
  elseif commonSteps:file_exists(config.pathToSDL .. "policy.sqlite") then
    return config.pathToSDL .. "policy.sqlite"
  else
    commonFunctions:userPrint(31, "policy.sqlite is not found" )
    return nil
  end
end

local function executeSqliteQuery(rawQueryString, dbFilePath)
  if not dbFilePath then
    return nil
  end
  local queryExecutionResult = {}
  local queryString = table.concat({"sqlite3 ", dbFilePath, " '", rawQueryString, "'"})
  local file = io.popen(queryString, 'r')
  if file then
    local index = 1
    for line in file:lines() do
      queryExecutionResult[index] = line
      index = index + 1
    end
    file:close()
    return queryExecutionResult
  else
    return nil
  end
end

local function isValuesCorrect(actualValues, expectedValues)
  if #actualValues ~= #expectedValues then
    return false
  end

  local tmpExpectedValues = {}
  for i = 1, #expectedValues do
    tmpExpectedValues[i] = expectedValues[i]
  end

  local isFound
  for j = 1, #actualValues do
    isFound = false
    for key, value in pairs(tmpExpectedValues) do
      if value == actualValues[j] then
        isFound = true
        tmpExpectedValues[key] = nil
        break
      end
    end
    if not isFound then
      return false
    end
  end
  if next(tmpExpectedValues) then
    return false
  end
  return true
end

function Test.checkLocalPT(checkTable)
  local expectedLocalPtValues
  local queryString
  local actualLocalPtValues
  local comparationResult
  local isTestPass = true
  for _, check in pairs(checkTable) do
    expectedLocalPtValues = check.expectedValues
    queryString = check.query
    actualLocalPtValues = executeSqliteQuery(queryString, constructPathToDatabase())
    if actualLocalPtValues then
      comparationResult = isValuesCorrect(actualLocalPtValues, expectedLocalPtValues)
      if not comparationResult then
        TestData:store(table.concat({"Test ", queryString, " failed: SDL has wrong values in LocalPT"}))
        TestData:store("ExpectedLocalPtValues")
        commonFunctions:userPrint(31, table.concat({"Test ", queryString, " failed: SDL has wrong values in LocalPT"}))
        commonFunctions:userPrint(35, "ExpectedLocalPtValues")
        for _, values in pairs(expectedLocalPtValues) do
          TestData:store(values)
          print(values)
        end
        TestData:store("ActualLocalPtValues")
        commonFunctions:userPrint(35, "ActualLocalPtValues")
        for _, values in pairs(actualLocalPtValues) do
          TestData:store(values)
          print(values)
        end
        isTestPass = false
      end
    else
      TestData:store("Test failed: Can't get data from LocalPT")
      commonFunctions:userPrint(31, "Test failed: Can't get data from LocalPT")
      isTestPass = false
    end
  end
  return isTestPass
end

function Test.backupPreloadedPT(backupPrefix)
  os.execute(table.concat({"cp ", config.pathToSDL, PRELOADED_PT_FILE_NAME, " ", config.pathToSDL, backupPrefix, PRELOADED_PT_FILE_NAME}))
end

function Test.restorePreloadedPT(backupPrefix)
  os.execute(table.concat({"mv ", config.pathToSDL, backupPrefix, PRELOADED_PT_FILE_NAME, " ", config.pathToSDL, PRELOADED_PT_FILE_NAME}))
end

local function updateJSON(pathToFile, updaters)
  local file = io.open(pathToFile, "r")
  local json_data = file:read("*a")
  file:close()

  local data = json.decode(json_data)
  if data then
    for _, updateFunc in pairs(updaters) do
      updateFunc(data)
    end
    -- Workaround. null value in lua table == not existing value. But in json file it has to be
    data.policy_table.functional_groupings["DataConsent-2"].rpcs = "tobedeletedinjsonfile"
    local dataToWrite = json.encode(data)
    dataToWrite = string.gsub(dataToWrite, "\"tobedeletedinjsonfile\"", "null")
    file = io.open(pathToFile, "w")
    file:write(dataToWrite)
    file:close()
  end

end

function Test.preparePreloadedPT()
  local preloadedUpdaters = {
    function(data)
      data.policy_table.app_policies[APP_ID] = TESTED_DATA.preloaded.policy_table.app_policies[APP_ID]
    end
  }
  updateJSON(config.pathToSDL .. PRELOADED_PT_FILE_NAME, preloadedUpdaters)
end

local function updatePolicyInDifferentSessions(self, PTName, appName, mobileSession)

  local iappID = self.applications[appName]
  --hmi side: sending SDL.GetURLS request
  local RequestIdGetURLS = self.hmiConnection:SendRequest("SDL.GetURLS", { service = 7 })

  --hmi side: expect SDL.GetURLS response from HMI
  EXPECT_HMIRESPONSE(RequestIdGetURLS,{result = {code = 0, method = "SDL.GetURLS", urls = {{url = "http://policies.telematics.ford.com/api/policies"}}}})
  :Do(function(_,_)
      --hmi side: sending BasicCommunication.OnSystemRequest request to SDL
      self.hmiConnection:SendNotification("BasicCommunication.OnSystemRequest",
        {
          requestType = "PROPRIETARY",
          fileName = "filename",
        }
      )
      --mobile side: expect OnSystemRequest notification

      mobileSession:ExpectNotification("OnSystemRequest", { requestType = "PROPRIETARY" })
      :Do(function(_,_)
          --mobile side: sending SystemRequest request
          local CorIdSystemRequest = mobileSession:SendRPC("SystemRequest",
            {
              fileName = "PolicyTableUpdate",
              requestType = "PROPRIETARY",
              appID = iappID
            },
            PTName)

          local systemRequestId
          --hmi side: expect SystemRequest request
          EXPECT_HMICALL("BasicCommunication.SystemRequest")
          :Do(function(_,_data1)
              systemRequestId = _data1.id
              --print("BasicCommunication.SystemRequest is received")

              --hmi side: sending BasicCommunication.OnSystemRequest request to SDL
              self.hmiConnection:SendNotification("SDL.OnReceivedPolicyUpdate",
                {
                  policyfile = "/tmp/fs/mp/images/ivsu_cache/PolicyTableUpdate"
                }
              )
              local function to_run()
                --hmi side: sending SystemRequest response
                self.hmiConnection:SendResponse(systemRequestId,"BasicCommunication.SystemRequest", "SUCCESS", {})
              end

              RUN_AFTER(to_run, 500)
            end)

          --hmi side: expect SDL.OnStatusUpdate
          EXPECT_HMINOTIFICATION("SDL.OnStatusUpdate")
          :ValidIf(function(exp,data)
              if
              exp.occurences == 1 and
              (data.params.status == "UP_TO_DATE" or data.params.status == "UPDATING"
                or data.params.status == "UPDATE_NEEDED") then
                return true
              elseif
                exp.occurences == 2 and
                data.params.status == "UP_TO_DATE" then
                  return true
                else
                  if
                  exp.occurences == 2 then
                    -- print ("\27[31m SDL.OnStatusUpdate came with wrong values. Expected in first occurrences status 'UP_TO_DATE' or 'UPDATING', got '" .. tostring(data.params.status) .. "' \27[0m")
                    -- elseif exp.occurences == 2 then
                    print ("\27[31m SDL.OnStatusUpdate came with wrong values. Expected in second occurrences status 'UP_TO_DATE', got '" .. tostring(data.params.status) .. "' \27[0m")

                    return false
                  end
                end
              end)
            :Times(Between(1,2))

            --mobile side: expect SystemRequest response
            mobileSession:ExpectResponse(CorIdSystemRequest, { success = true, resultCode = "SUCCESS"})
            :Do(function(_,_)
                --hmi side: sending SDL.GetUserFriendlyMessage request to SDL
                local RequestIdGetUserFriendlyMessage = self.hmiConnection:SendRequest("SDL.GetUserFriendlyMessage", {language = "EN-US", messageCodes = {"StatusUpToDate"}})

                --hmi side: expect SDL.GetUserFriendlyMessage response
                EXPECT_HMIRESPONSE(RequestIdGetUserFriendlyMessage,{result = {code = 0, method = "SDL.GetUserFriendlyMessage"}})
              end)

          end)
      end)

  end

  local function activateAppInSpecificLevel(self, HMIAppID, hmi_level)
    local RequestId = self.hmiConnection:SendRequest("SDL.ActivateApp", { appID = HMIAppID, level = hmi_level})

    EXPECT_NOTIFICATION("OnHMIStatus", {hmiLevel = hmi_level, systemContext = "MAIN" })
    --hmi side: expect SDL.ActivateApp response
    EXPECT_HMIRESPONSE(RequestId)
    :Do(function(_,data)
        --In case when app is not allowed, it is needed to allow app
        if data.result.isSDLAllowed ~= true then
          --hmi side: sending SDL.GetUserFriendlyMessage request
          RequestId = self.hmiConnection:SendRequest("SDL.GetUserFriendlyMessage",
            {language = "EN-US", messageCodes = {"DataConsent"}})

          EXPECT_HMIRESPONSE(RequestId)
          :Do(function(_,_)

              --hmi side: send request SDL.OnAllowSDLFunctionality
              self.hmiConnection:SendNotification("SDL.OnAllowSDLFunctionality",
                {allowed = true, source = "GUI", device = {id = config.deviceMAC, name = "127.0.0.1"}})

              --hmi side: expect BasicCommunication.ActivateApp request
              EXPECT_HMICALL("BasicCommunication.ActivateApp")
              :Do(function(_,data2)

                  --hmi side: sending BasicCommunication.ActivateApp response
                  self.hmiConnection:SendResponse(data2.id,"BasicCommunication.ActivateApp", "SUCCESS", {})
                end)
              -- :Times()
            end)
        end
      end)
  end

  local function addApplicationToPTJsonFile(basic_file, new_pt_file, app_name, app_)
    local pt = io.open(basic_file, "r")
    if pt == nil then
      error("PTU file not found")
    end
    local pt_string = pt:read("*all")
    pt:close()
    local pt_table = json.decode(pt_string)
    pt_table["policy_table"]["app_policies"][app_name] = app_
    -- Workaround. null value in lua table == not existing value. But in json file it has to be
    pt_table["policy_table"]["functional_groupings"]["DataConsent-2"]["rpcs"] = "tobedeletedinjsonfile"
    local pt_json = json.encode(pt_table)
    pt_json = string.gsub(pt_json, "\"tobedeletedinjsonfile\"", "null")
    local new_ptu = io.open(new_pt_file, "w")

    new_ptu:write(pt_json)
    new_ptu:close()
  end

  local function PrepareJsonPTU1(name, new_ptufile)
    local json_app = [[ {
      "keep_context": false,
      "steal_focus": false,
      "priority": "NONE",
      "default_hmi": "NONE",
      "groups": [
      "Base-4"
      ],
      "RequestType":[
      "TRAFFIC_MESSAGE_CHANNEL",
      "PROPRIETARY",
      "HTTP",
      "QUERY_APPS"
      ]
    }]]
    local app = json.decode(json_app)
    addApplicationToPTJsonFile(basic_ptu_file, new_ptufile, name, app)
  end

  --[[ Preconditions ]]
  commonFunctions:newTestCasesGroup("Preconditions")

  function Test:Precondition_StopSDL()
    TestData:init(self)
    StopSDL()
  end

  function Test:Precondition_PreparePreloadedPT()
    commonSteps:DeletePolicyTable()
    TestData:store("Store initial PreloadedPT", config.pathToSDL .. PRELOADED_PT_FILE_NAME, "initial_" .. PRELOADED_PT_FILE_NAME)
    self.backupPreloadedPT("backup_")
    self:preparePreloadedPT()
    TestData:store("Store updated PreloadedPT", config.pathToSDL .. PRELOADED_PT_FILE_NAME, "updated_" .. PRELOADED_PT_FILE_NAME)
  end

  function Test:Precondition_StartSDL()
    StartSDL(config.pathToSDL, config.ExitOnCrash, self)
  end

  function Test:Precondition_InitHMIandMobileApp()
    self:initHMI()
    self:initHMI_onReady()
    self:connectMobile()
    self.mobileSession = mobile_session.MobileSession(self, self.mobileConnection)
  end

  --[[ Test ]]
  commonFunctions:newTestCasesGroup("Test")

  function Test:RegisterApp()
    self.mobileSession:StartService(7)
    :Do(function (_,_)
        local correlationId = self.mobileSession:SendRPC("RegisterAppInterface", TESTED_DATA.application.registerAppInterfaceParams)
        EXPECT_HMINOTIFICATION("BasicCommunication.OnAppRegistered")
        :Do(function(_,data)
            HMIAppId = data.params.application.appID
          end)
        EXPECT_RESPONSE(correlationId, { success = true })
        EXPECT_NOTIFICATION("OnPermissionsChange")
      end)
  end

  function Test.PreparePTData()
    PrepareJsonPTU1(APP_ID, ptu_first_app_registered)
  end

  function Test:ActivateApp()
    activateAppInSpecificLevel(self,HMIAppId,"FULL")
  end

  function Test:InitiatePTUForGetSnapshot()
    EXPECT_HMICALL("BasicCommunication.PolicyUpdate")
    updatePolicyInDifferentSessions(Test, ptu_first_app_registered,
      TESTED_DATA.application.registerAppInterfaceParams.appName, self.mobileSession)
  end

  function Test:StopSDL2()
    StopSDL(self)
  end

  function Test:CheckPTUinLocalPT()
    TestData:store("Store LocalPT after test", constructPathToDatabase(), "final_policy.sqlite" )
    local checks = {
      {
        query = table.concat(
          {
            'select app_registration_language_vui from app_level where application_id = "',
            APP_ID,
            '"'
          }),
        expectedValues = {table.concat(
            {
              TESTED_DATA.expected.policy_table.usage_and_error_counts.app_level[APP_ID].app_registration_language_vui, ""
            })
        }
      }
    }
    if not self.checkLocalPT(checks) then
      self:FailTestCase("SDL has wrong values in LocalPT")
    end
  end

  function Test:CheckValueFromPTAfterSecondRegistration()
    TestData:store("Store PT Snapshot after test", snapshot_path, "final_sdl_snapshot.json" )
    local snapshot = assert(io.open(snapshot_path, "r"))
    local fileContent = snapshot:read("*all")
    snapshot.close()
    local snapshot_table = json.decode(fileContent)
    local actual_value = snapshot_table["policy_table"]["usage_and_error_counts"]["app_level"]["0000001"]["app_registration_language_vui"]
    if actual_value ~= APP_LANGUAGE then
      self:FailTestCase("Unexpected value in DB is :" .. tostring(actual_value))
    end

  end

  --[[ Postconditions ]]
  commonFunctions:newTestCasesGroup("Postconditions")

  function Test.Postcondition()
    commonSteps:DeletePolicyTable()
    Test.restorePreloadedPT("backup_")
    TestData:info()
  end

  return Test
